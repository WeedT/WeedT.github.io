<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Linux 命令 - 3]]></title>
      <url>https://weedt.github.io/2016/04/12/Commonds-Of-Linux-3/</url>
      <content type="html"><![CDATA[<h3 id="链接文件"><a href="#链接文件" class="headerlink" title="链接文件"></a>链接文件</h3><ol>
<li><strong>ln</strong><br>创建链接。格式：<br><p style="text-align: center; font-weight: bold; margin: 0px;">ln [选项] 源文件 [目标文件]</p><br>链接文件对象可以是目录也可以是文件。如果链接指向目录，用户就可以直接利用该链接直接进入该链接的目录，不用给出到达该目录的路径，删除该链接，也不会破坏原来的目录。<br>选项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-s   建立符号链接，而不是硬链接</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>符号链接 <strong>不是一个独立的文件</strong>， 它的属性依赖于源文件，所以给符号链接文件设置存取权限是没有意义的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 命令 - 2]]></title>
      <url>https://weedt.github.io/2016/04/09/Commonds-Of-Linux-2/</url>
      <content type="html"><![CDATA[<h3 id="比较文件内容"><a href="#比较文件内容" class="headerlink" title="比较文件内容"></a>比较文件内容</h3><ol>
<li><p><strong>comm</strong><br>对两个以及排序好的文件进行逐行比较。结果生成3列：仅在file1中出现的行，仅在file2中出现的行，在两个文件中都出现的行。格式：<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">comm [-123] 文件1 文件2</p><p></p>
<a id="more"></a>
<p>常用选项：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-123   1,2,3分别表示不显示输出中的第一列，第二列，第三列。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>diff</strong><br>比较两个文本文件，找出不同，不要求文件以及排序。格式：<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">diff [选项] 文件1 文件2</p><br>比较两个文件的不同之处，并且提供让两个文件相同的修改方法。如果两个文件完全一样，不显示输出。该命令显示的一般形式：<br>n1 a n3,n4      （文件1的n1行附加到文件2n3～n4行）<br>n1,n2 d n3      （将文件1的n1～n2行和文件2的n3行）<br>n1,n2 c n3,n4   （将文件1的n1～n2改为文件2的n3～n4）<br>默认是<br>常用选项：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-b，--ignore-space-change 　不检查空格字符的不同。</span><br><span class="line">-B，--ignore-blank-lines 　不检查空白行。</span><br><span class="line">-c   输出是带上下文的三行模式</span><br><span class="line">-C NUM   输出是带上下文的NUM行模式</span><br><span class="line">-e   输出合法的ed脚本</span><br><span class="line">-i   忽略字母大小写</span><br><span class="line">-r   当两个文件是目录时，递归查找子目录</span><br><span class="line">-q，--brief 　仅显示有无差异，不显示详细的信息。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Tip：如果file1或者file2是目录时，则diff会利用目录下的同名文件比较。如果指定比较的是目录的的时候，diff命令会比较两个目录下名字相同的文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。</p>
<h3 id="复制删除移动文件"><a href="#复制删除移动文件" class="headerlink" title="复制删除移动文件"></a>复制删除移动文件</h3><ol>
<li><strong>cp</strong><br>复制文件或者目录。格式：<br><p style="text-align: center; font-weight: bold; margin: 0px;">cp [选项] 源文件或目录 目的文件或目录</p><br>如果是目录，一般都需要“-r“来递归复制目录下文件。<br>常用选项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-a，--archive    等于-dR --preserve=all</span><br><span class="line">    --backup[=CONTROL    为每个已存在的目标文件创建备份，保留文件链接和属性。</span><br><span class="line">-b    类似--backup 但不接受参数</span><br><span class="line">   --copy-contents 在递归处理是复制特殊文件内容</span><br><span class="line">-d   等于--no-dereference --preserve=links</span><br><span class="line">-f，--force   如果目标文件无法打开则将其移除并重试(当-n选项存在时则不需再选此项)</span><br><span class="line">-i，--interactive   覆盖前询问(使前面的 -n 选项失效)</span><br><span class="line">-H   跟随源文件中的命令行符号链接</span><br><span class="line">-l，--link   链接文件而不复制</span><br><span class="line">-L，--dereference   总是跟随符号链接</span><br><span class="line">-n，--no-clobber   不要覆盖已存在的文件(使前面的 -i 选项失效)</span><br><span class="line">-P，--no-dereference   不跟随源文件中的符号链接</span><br><span class="line">-p   等于--preserve=模式,所有权,时间戳</span><br><span class="line">   --preserve[=属性列表   保持指定的属性(默认：模式,所有权,时间戳)，如果可能保持附加属性：环境、链接、xattr 等</span><br><span class="line">-R，-r，--recursive   复制目录及目录内的所有项目</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Tip：如果把文件复制到一个目的文件，而目标文件已存在，那么目的文件的内容将被破坏。</p>
<ol>
<li><strong>rm</strong><br>rm命令可以删除文件和目录。格式：<br><p style="text-align: center; font-weight: bold; margin: 0px;">rm [选项] 文件…</p><br>常用选项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d   删除目录不管是否空（超级用户才行）</span><br><span class="line">-f，--force   忽略不存在的文件，从不给出提示。</span><br><span class="line">-i，--interactive   进行交互式删除</span><br><span class="line">-r，-R, --recursive   指示rm将参数中列出的全部目录和子目录均递归地删除。</span><br><span class="line">-v，--verbose   详细显示进行的步骤</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Tip：这个命令很危险，特别是“-fr <em>”。文件可以使用通配符“</em>”。</p>
<ol>
<li><strong>mv</strong><br>用来移动文件或者目录，或者对文件或目录进行重命名。格式<br><p style="text-align: center; font-weight: bold; margin: 0px;">mv [选项] 源 目的</p><br>源是文件，目的是文件，若两者不同目录，源移动到目的目录下，重命名为目的，同名文件覆盖，否则将源重命名为目的。源是文件，目的是目录，将文件移动到目的下，同名覆盖。源是目录，目的是目录，将源目录移动到目的目录下。<br>常用选项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b   若需覆盖文件，则覆盖前先行备份。 </span><br><span class="line">-f   force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</span><br><span class="line">-i   若目标文件 (destination) 已经存在时，就会询问是否覆盖！</span><br><span class="line">-u   若目标文件已经存在，且 source 比较新，才会更新(update)</span><br><span class="line">-t，--target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY   即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="文件内容统计"><a href="#文件内容统计" class="headerlink" title="文件内容统计"></a>文件内容统计</h3><ol>
<li><strong>wc</strong><br>统计文件字节数、字数、行数。字是指空格隔开的字符串。格式：<br><p style="text-align: center; font-weight: bold; margin: 0px;">wc [选项] 文件…</p><br>如果没有指定文件或用“-”指定，则从标准输入读取数据。多个文件，则输出统计总数。<br>wc输出列的数目和顺序不受选项的顺序和数目的影响，总是按以下格式显示，并且每项只占一列：<br><p style="text-align: center; font-weight: bold; margin: 0px;">行数   字数  字节数  文件名</p><br>常用选项:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-c   字节数</span><br><span class="line">-l   行数</span><br><span class="line">-w   字数</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>示例：<br><img src="http://ww1.sinaimg.cn/large/93736429gw1f2t4kv9vuej20dk016dg2.jpg" alt=""></p>
<h3 id="创建和删除目录的命令"><a href="#创建和删除目录的命令" class="headerlink" title="创建和删除目录的命令"></a>创建和删除目录的命令</h3><ol>
<li><p><strong>mkdir</strong><br>创建目录。格式：<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">mkdir [选项] 目录名</p><br>如果目录名前没有路径名，则在当前目录下创建，否则在指定路径下创建目录，若路径不存在则不创建。不能有同名目录。<br>常用选项：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-m NUM，--mode=模式，设定权限&lt;模式&gt; </span><br><span class="line">-p，--parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; </span><br><span class="line">-v，--verbose  每次创建新目录都显示信息</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>rmdir</strong><br>删除目录，从一个目录删除一个或多个子目录。<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">rmdir [选项] 目录名</p><br>如果目录名中没有指定路径，则删除当前目录下由目录名指定的目录，否则，删除指定位置的目录。删除目录时必须具有对其父目录的写权限。<br>常用选项：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-p   递归删除目录，当子目录删除后父目录为空，也一同被删除。如果有非空目录，则保留。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Tip：子目录被删除时，应该为空。也就是说，文件必须用rm全部删除，如果目录中还有文件，就不能用rmdir删除。另外，当前目录必须位于删除目录之上。</p>
<ol>
<li><p><strong>cd</strong><br>改变工作目录。格式：<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">cd [目录名]</p><br>若不指定目录名，默认为用户主目录<br>. 当前目录<br>.. 父目录<br>～ 用户主目录<br>/ 根目录<p></p>
</li>
<li><p><strong>pwd</strong><br>显示当前目录的觉得路径，该命令不带任何参数和选项。</p>
</li>
<li><p><strong>ls</strong><br>列出指定目录的内容。格式：<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">ls [选项] [目录或文件] </p><br>如果给出的参数是目录，则列出所有子目录与文件的信息；如果是文件，列出有关该文件属性的一些信息。默认情况下输出条目按字母顺序排序。若没给出参数，将显示当前目录下所有子目录和文件信息。<br>常用选项：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">-a，--all    列出目录下的所有文件，包括以“.”开头的隐含文件</span><br><span class="line">-A   同-a，但不列出“.”和“..”。</span><br><span class="line">-b   当文件名包含不可显示字符时，用\ddd（三位八进制）形式显示</span><br><span class="line">-c   配合 -lt：根据 ctime 排序及显示 ctime (文件修改时间)</span><br><span class="line">     配合 -l：显示 ctime 但根据名称排序</span><br><span class="line">     单独：根据 ctime 排序</span><br><span class="line">-C   每栏由上至下列出项目</span><br><span class="line">--color[=WHEN]   控制是否使用色彩分辨文件。WHEN 可以是&apos;never&apos;、&apos;always&apos;或&apos;auto&apos;其中之一</span><br><span class="line">-d，--directory   将目录象文件一样显示，而不是显示其下的文件。</span><br><span class="line">-f   对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</span><br><span class="line">-g   类似 -l，但不列出所有者</span><br><span class="line">-G，--no-group   不列出任何有关组的信息</span><br><span class="line">-h，--human-readable   以容易理解的格式列出文件大小 (例如 1K 234M 2G)</span><br><span class="line">--si   类似 -h,但文件大小取 1000 的次方而不是 1024</span><br><span class="line">-H，--dereference-command-line   使用命令列中的符号链接指示的真正目的地</span><br><span class="line">-i，--inode   在输出第一列先死文件的I结点号</span><br><span class="line">-k   即 –block-size=1K，以 k 字节的形式表示文件的大小。</span><br><span class="line">-l   除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</span><br><span class="line">-L，--dereference   当显示符号链接的文件信息时，显示链接的对象而并非符号链接本身的信息</span><br><span class="line">-m   所有项目以逗号分隔，并填满整行行宽</span><br><span class="line">-o   类似 -l，显示文件的除组信息外的详细信息。   </span><br><span class="line">-r，--reverse   依相反次序排列</span><br><span class="line">-R，--recursive   同时列出所有子目录层</span><br><span class="line">-s，–size   以块大小为单位列出所有文件的大小</span><br><span class="line">-S   根据文件大小排序</span><br><span class="line">--sort=WORD   以下是可选用的 WORD 和它们代表的相应选项：</span><br><span class="line">extension -X status -c</span><br><span class="line">none -U time -t</span><br><span class="line">size -S atime -u</span><br><span class="line">time -t access -u</span><br><span class="line">version -v use -u</span><br><span class="line">-t   以文件修改时间排序</span><br><span class="line">-u   配合 -lt:显示访问时间而且依访问时间排序</span><br><span class="line">     配合 -l:显示访问时间但根据名称排序</span><br><span class="line">     单独：根据访问时间排序</span><br><span class="line">-U   不进行排序；依文件系统原有的次序列出项目</span><br><span class="line">-x   逐行列出项目而不是逐栏列出</span><br><span class="line">-X   根据扩展名排序</span><br><span class="line">-1   每行只列出一个文件（是数字1，不是i或者l）</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>需要说明的是长格式信息，信息分为多列：<br>文件类型与权限  链接数  文件主  文件组  文件大小  建立或最近修改时间  文件名<br>drwxr-xr-x  26 root root  4096  3月 25 15:04 lib<br>字段说明：<br>1.第一个字段开头第一个字符表示文件类型。<br>    -  普通文件<br>    d  目录<br>    b  块设备文件<br>    c  字符设备文件<br>    l  符号链接文件<br>2.随后9个字符表示文件存取权限。<br>    r  读<br>    w  写<br>    x  执行。对于目录，表示可访问。<br>    s  当文件被执行是，把该文件的GID或UID赋予执行进程的UID（userID）或GID（groupID）<br>    t  设置了粘着标志位（留在内存，不被删除）。如果该文件是目录，则该目录的文件只能被超级用户、文件主删除。如果是可执行文件，在文件执行后，指向其正文段的指针。再次执行它时，系统就能更快地装入该文件。<br>    -  没有设置权限<br>3.对于符号链接文件，在最后“文件名”字段显示的形式是：<br>    符号链接文件名-&gt;目标文件的路径名<br>4.对于设备文件。其“文件大小”字段显示的是设备的主、次设备号。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo下表格显示问题]]></title>
      <url>https://weedt.github.io/2016/04/08/Show-Table-in-Hexo/</url>
      <content type="html"><![CDATA[<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>Hexo说是支持GitHub Flavored Markdown的所有功能，那么Hexo就是支持表格的。<br>通过：</p>
<blockquote>
<p>|项目|数目|<br>|1|2|<br>|2|2|<br>|3|5|</p>
</blockquote>
<a id="more"></a>
<p>来显示一个表格。然而，这貌似有主题限制的。有的主题支持而一些是不支持的，比如我用的是maupassant主题，就不支持表格。然而我又不想贴图片，只能用HTML标签来实现（网上有人说在Markdown中使用HTML标签需要前后空一行，然而我不空行也可以，而且可以在行内使用span来给文字加颜色）。我就在Markdown中加入了如下代码：<br><img src="http://ww4.sinaimg.cn/mw690/93736429gw1f2pamp4fchj20bb082dg7.jpg" alt=""><br>结果效果如下图，表格的上方有一大片空白：<br><img src="http://ww3.sinaimg.cn/mw690/93736429gw1f2pazl0wdpj20ih08qmxb.jpg" alt=""><br>打开生成的源文件，发现了一堆br：<br><img src="http://ww2.sinaimg.cn/mw690/93736429gw1f2pb300d0sj20ar05ndfw.jpg" alt=""></p>
<p>问题就是这一堆br是从哪儿来的。怀着猜想，我把HTML的代码改了一下，变成了这样：<br><img src="http://ww2.sinaimg.cn/mw690/93736429gw1f2pb5lje31j20hv048ta2.jpg" alt=""><br>然后就可以了：<br><img src="http://ww1.sinaimg.cn/mw690/93736429gw1f2pb65m1waj20e20bb3zg.jpg" alt=""></p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在Hexo中用HTML标签时务必写成一行，不然文本中的换行会被Markdown解释成br</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux 命令 - 1]]></title>
      <url>https://weedt.github.io/2016/04/02/Commonds-Of-Linux-1/</url>
      <content type="html"><![CDATA[<h3 id="TIPs"><a href="#TIPs" class="headerlink" title="TIPs"></a>TIPs</h3><ul>
<li>Bash命令基本格式：<p style="text-align: center; font-weight: bold; margin: 0px;">命令名 [选项] [参数1] [参数2] ……</p></li>
<li>命令名小写： DATE，Date和date是不同的，只有date是正确的。</li>
<li>如果命令太长，一行放不下，可以在行尾输入“\”字符，shell会返回一个“&gt;”作为提示符，表示命令未结束，允许继续输入有关信息。</li>
<li>命令与选项和参数之间要用空格或者制表符隔开。多个空格会被shell解释为单个空格。</li>
</ul>
<a id="more"></a>
<h3 id="一些简单命令"><a href="#一些简单命令" class="headerlink" title="一些简单命令"></a>一些简单命令</h3><ol>
<li><p><strong>who</strong><br>列出所有正在使用 <em>系统的用户</em>、<em>所用终端名</em>和 <em>注册到系统的时间</em><br><img src="http://ww2.sinaimg.cn/large/93736429gw1f2ig5p43rpj20b5024q3i.jpg" alt=""><br>who am i 和 whoami：<br><img src="http://ww1.sinaimg.cn/large/93736429gw1f2ig9rqw3rj20ax023q3f.jpg" alt=""></p>
</li>
<li><p><strong>echo</strong><br>将命令行的参数显示在屏幕上：<br><img src="http://ww1.sinaimg.cn/large/93736429gw1f2igefoae2j20e7041jso.jpg" alt=""></p>
</li>
<li><p><strong>date</strong><br>显示或者设置系统日期和时间，详细请传送<a href="http://www.cnblogs.com/peida/archive/2012/12/13/2815687.html" title="每天一条Linux命令" target="_blank" rel="external">这里</a>。</p>
</li>
<li><p><strong>cal</strong><br>日历，显示1-9999年任意一年的或者月的日历。不带参数显示当月，一个参数解释为 <em>年</em>，两个参数解释为 <em>月 年</em></p>
</li>
</ol>
<h3 id="文件操作命令"><a href="#文件操作命令" class="headerlink" title="文件操作命令"></a>文件操作命令</h3><ol>
<li><strong>cat</strong><br>连接文件并打印到标准输出设备上，经常用来显示内容。主要两个功能：<strong>显示文件，连接两个或多个文件</strong>。格式：<br><p style="text-align: center; font-weight: bold; margin: 0px;">cat [选项]… 文件…</p><br>常用选项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-b，--number-noblank     从1对所有非空行编号</span><br><span class="line">-n，--number   从1对所有行编号</span><br><span class="line">-s，--squeeze-blank    将多个相邻空行何必成一个空行</span><br><span class="line">--help 用法帮助</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>示例：<br>$ cat f1          //显示f1文件<br>$ cat f1 f2       //同时显示f1、f2文件<br>$ cat f1 f2 &gt; f3  //将f1 f2合并放入f3文件</p>
<ol>
<li><strong>more</strong><br>分屏显示文件内容，显示满屏后停下。格式：<br><p style="text-align: center; font-weight: bold; margin: 0px;">more [选项] 文件…</p><br>常用选项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-num    指定一屏显示多少行</span><br><span class="line">-d   提供更友好的提示信息</span><br><span class="line">-c/-p   不滚屏，在显示下一屏之前先清屏</span><br><span class="line">-s   将连续空行合并成一行</span><br><span class="line">+/   模式搜索中向上搜索</span><br><span class="line">+num   从第num行开始显示</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>操作：</p>
<ul>
<li>空格键：显示文本下一屏</li>
<li>Enter：下一行</li>
<li>斜线符（/），然后输入模式，可以在文本中寻找下一个匹配的模式</li>
<li>H：帮助</li>
<li>B：上一屏</li>
<li>Q：退出more命令</li>
</ul>
<ol>
<li><strong>less</strong><br>和more类似可以分屏显示文件内容，不同是less能向前或向后浏览文件，而more只能向前浏览（？）。总体来说less比more功能强大。格式：<br><p style="text-align: center; font-weight: bold; margin: 0px;">less [选项] 文件…</p><br>常用选项：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-e   当文件显示结束后，自动离开</span><br><span class="line">-f   强迫打开特殊文件，例如外围设备代号、目录和二进制文件</span><br><span class="line">-g   只标志最后搜索的关键词</span><br><span class="line">-i   忽略搜索时的大小写</span><br><span class="line">-m   显示类似more命令的百分比</span><br><span class="line">-N   显示每行的行号</span><br><span class="line">-o &lt;文件名&gt;   将less 输出的内容在指定文件中保存起来</span><br><span class="line">-s   显示连续空行为一行</span><br><span class="line">-x &lt;数字&gt;   将“tab”键显示为规定的数字空格</span><br><span class="line">/字符串   向下搜索“字符串”的功能</span><br><span class="line">?字符串   向上搜索“字符串”的功能</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>操作：</p>
<ul>
<li>n：重复前一个搜索（与 / 或 ? 有关）</li>
<li>N：反向重复前一个搜索（与 / 或 ? 有关）</li>
<li>b：向前翻一页</li>
<li>d：向后翻半页</li>
<li>h：显示帮助界面</li>
<li>Q：退出less 命令</li>
<li>u：向前滚动半页</li>
<li>y：向前滚动一行</li>
<li>空格键：滚动一行</li>
<li>回车键：滚动一页</li>
<li>Pagedown：向下翻动一页</li>
<li>Pageup；向上翻动一页<br>Tip：less可以浏览多个文件，输入 <strong>“:p”和”:n”</strong>向前向后切换文件。</li>
</ul>
<ol>
<li><p><strong>head</strong><br>在屏幕上显示指定文件的开头若干行。格式：<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">head [选项]… 文件…</p><br>常用选项：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c，--bytes=SIZE   显示前size个字节</span><br><span class="line">-n，--lines=NUMBER   指定显示行数，默认10行</span><br><span class="line">-q，-quiet，--silent   不显示文件标题</span><br><span class="line">-v，--verbose   始终显示标题</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>tail</strong><br>在屏幕上显示指定文件的末尾若干行。格式：<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">tail [选项]… 文件…</p><br>常用选项：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c，--bytes=SIZE   显示前size个字节</span><br><span class="line">-f   当文件增长时输出附加的数据</span><br><span class="line">-n，--lines=NUMBER   指定显示行数，默认10行</span><br><span class="line">-q，-quiet，--silent   不显示文件标题</span><br><span class="line">-v，--verbose   始终显示标题</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Tip：如果字节或者行数前有一个”+“，则表示从文件开头第N项显示，而不是显示文件最后N项。</p>
<ol>
<li><p><strong>touch</strong><br>可以修改指定文件的时间标签或者创建一个空文件。如果文件存在，默认情况下，将时间标签更新为系统当前时间，数据不改变；如果文件不存在，则创建一个空文件。<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">touch [选项] 文件…</p><br>常用选项：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a   仅改变存取时间</span><br><span class="line">-c   不创建任何文件</span><br><span class="line">-m   仅改变文件修改时间</span><br><span class="line">-t STAMP   使用STAMP指定的时间标签，而不是系统当前时间，格式为[[CC]YY]MMDDhhmm[.ss]，CC代表年前两位，YY是后两位。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>grep</strong> = Global Regular Expression Print<br>在文本中查找指定模式的词或短语，并在标准输出上显示包括给定字符串模式的所有行。该命令组包含三个命令：grep，egrep，fgrep。grep一次只能搜索一个指定的模式；egrep相当于gerp -E，可以使用扩展的字符串模式进行搜索；fgrep相当于grep -F，是快速搜索命令，检索固定字符串，不识别正则表达式。格式：<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">grep [选项] 模式 文件…</p><br>常用选项：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-a，--text   不要忽略二进制的数据。   </span><br><span class="line">-A NUMBER，--after-context=NUMBER    显示符合范本样式的那一行以及后面NUMBER行</span><br><span class="line">-b，--byte-offset   在显示符合样式的那一行之前，标示出该行第一个字符的编号。   </span><br><span class="line">-B NUMBER，--before-context=NUMBER   显示符合样式的那一行及该行之前NUMBER行。   </span><br><span class="line">-c，--count   计算符合样式的列数。</span><br><span class="line">-C NUMBER    --context=NUMBER或-NUMBER   显示符合样式的行以及该行之前后的NUMBER行。   </span><br><span class="line">-d &lt;动作&gt;，--directories=&lt;动作&gt;   当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。   </span><br><span class="line">-e &lt;范本样式&gt;，--regexp=&lt;范本样式&gt;   指定字符串做为查找文件内容的样式。   </span><br><span class="line">-E,--extended-regexp   将样式为延伸的普通表示法来使用。</span><br><span class="line">-f &lt;规则文件&gt;，--file=&lt;规则文件&gt;   从文件中获取模式，每行一个规则样式。空文件不包含模式，不做匹配</span><br><span class="line">-F，--fixed-regexp   #将样式视为固定字符串的列表。</span><br><span class="line">-G，--basic-regexp   #将样式视为普通的表示法来使用。</span><br><span class="line">-h，--no-filename   #在显示符合样式的那一行之前，不标示该行所属的文件名称。</span><br><span class="line">-H，--with-filename   #在显示符合样式的那一行之前，表示该行所属的文件名称。</span><br><span class="line">-i，--ignore-case   #忽略字符大小写的差别。</span><br><span class="line">-l，--file-with-matches   #列出文件内容符合指定的样式的文件名称。</span><br><span class="line">-L，--files-without-match   #列出文件内容不符合指定的样式的文件名称。</span><br><span class="line">-n，--line-number   在显示符合样式的那一行之前，标示出该行的列数编号。</span><br><span class="line">-q，--quiet或--silent   不显示任何信息。</span><br><span class="line">-r，--recursive   此参数的效果和指定“-d recurse”参数相同。</span><br><span class="line">-s，--no-messages   不显示错误信息。</span><br><span class="line">-v，--revert-match   显示不包含匹配文本的所有行。</span><br><span class="line">-w，--word-regexp   只显示全字符合的列。</span><br><span class="line">-x，--line-regexp   只显示全列符合的列。</span><br><span class="line">-y 此参数的效果和指定“-i”参数相同。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Tip：在文件列表中可以使用通配符号“*”。模式中有空格，应该将模式用单引号括起来</p>
<ol>
<li><p><strong>sort</strong><br>对文本文件各行进行排序。格式：<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">sort [选项] 文件列表</p><br>sort将逐行对文件的所有行进行排序，显示在标准输出上。如果不指定文件或使用“-”表示文件，则排序内容来自标准输入（ctrl+d开始排序）。排序比较是依据从输入文件的每一行提取的一个或者多个关键字进行的。排序关键字定义了，用来排序的最小字符序列。默认情况下，排序关键字的顺序有系统使用的 <strong>字符集</strong>决定。<br>常用选项：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-b   忽略每行前面开始出的空格字符。</span><br><span class="line">-c   检查文件是否已经按照顺序排序。</span><br><span class="line">-f   排序时，忽略大小写字母。</span><br><span class="line">-M   将前面3个字母依照月份的缩写进行排序。</span><br><span class="line">-n   依照数值的大小排序。</span><br><span class="line">-i   忽略非打印字符。</span><br><span class="line">-o &lt;输出文件&gt;   将排序后的结果存入指定的文件。从重定向符“&gt;”也可以，不过后者不支持输入到源文件。</span><br><span class="line">-r   以相反的顺序来排序。</span><br><span class="line">-t &lt;分隔字符&gt;   指定排序时所用的栏位分隔字符。</span><br><span class="line">-k n1[,n2]   指定从文本的第n1字段开始到n2字段中间的内容作为排序关键字。如果没有n2，则是从n1开始到行结尾的所有字段，n1/n2可以是小数，代表“字段.字符”，都是从1开始计算。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>uniq</strong><br>该命令从排好序的文件中去除重复行。比较相邻行，去掉重复行，只留下一行。该命令加工后的结果写到输出文件中，输入文件和输出文件必须不同。如果输入文件用”-“表示，则从标准输入上读取。格式：<br></p><p style="text-align: center; font-weight: bold; margin: 0px;">uniq [选项] [输入文件 [输出文件]] </p><br>常用选项：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c，--count   在每列旁边显示该行重复出现的次数。</span><br><span class="line">-d，--repeated   仅显示重复出现的行列。</span><br><span class="line">-f NUMBER，--skip-fields=NUMBER   忽略比较前NUMBER行。</span><br><span class="line">-s UMBER，--skip-chars=NUMBER   忽略比较前NUMBER个字符。</span><br><span class="line">-u或--unique   仅显示出一次的行列。</span><br><span class="line">-w&lt;字符位置&gt;，--check-chars=&lt;字符位置&gt;   指定要比较的字符。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>参考：<a href="http://www.cnblogs.com/peida/tag/%E6%AF%8F%E6%97%A5%E4%B8%80linux%E5%91%BD%E4%BB%A4/" target="_blank" rel="external">每天一Linux命令</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[OpenGL纹理映射基本知识小结]]></title>
      <url>https://weedt.github.io/2015/12/16/A-Brief-Summary-Of-OpenGL-Texture/</url>
      <content type="html"><![CDATA[<p>这些天在做项目时需要修复项目时的纹理问题，特此总结一下OpenGL纹理相关的知识。<br><a id="more"></a></p>
<h3 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h3><hr>
<p><strong>glTexImage2D</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void glTexImage2D(GLenum target, GLint level, GLint internalFormat,</span><br><span class="line">    GLsizei width, GLsizei height, GLint border,</span><br><span class="line">    GLenum format, GLenum type, const GLvoid* data);</span><br></pre></td></tr></table></figure></p>
<p><strong>定义一个二维纹理或者一维纹理数组</strong>。参数说明：<br>target: 指定纹理单元的类型，必须指定为GL_TEXTURE_2D,GL_PROXY_TEXTURE_2D, GL_TEXTURE_CUBE_MAP_POSITIVE_X, GL_TEXTURE_CUBE_MAP_NEGATIVE_X, GL_TEXTURE_CUBE_MAP_POSITIVE_Y, GL_TEXTURE_CUBE_MAP_NEGATIVE_Y, GL_TEXTURE_CUBE_MAP_POSITIVE_Z, GL_TEXTURE_CUBE_MAP_NEGATIVE_Z, or GL_PROXY_TEXTURE_CUBE_MAP来定义二维纹理，或者指定GL_TEXTURE_1D_ARRAY， GL_PROXY_TEXTURE_1D_ARRAY来定义一维纹理数组。<br>level：如果使用了多种分辨率的纹理（mipmap），可以使用level，如果没有，就要把level设为0。<br><strong>internalFormat</strong>：指定OpenGL是如何管理纹理单元中数据格式的，确定那些成分（RGBA、深度、亮度或强度）被选定为图像的纹理单元。（网络上很多解释说这个参数必须和后面的format参数一样，这个说法是不正确的）。<br>width：指定纹理单元的宽度。<br>height：指定纹理单元的高度。<br>border：指定纹理单元的边框，如果包含边框取值为1，不包含边框取值为0。<br><strong>format</strong>：指定data所指向的数据的格式。<br>type：指定data所指向的数据的类型。<br>data：纹理数据。<br>对于internalFormat和format，由于取值类型基本上一致，很容易混淆和误解。 <strong>需要说明的是，internalFormat是指生成的纹理单元的格式，而format是指data的格式</strong>，如果两者格式一样，就不需要转换可以直接传输。否则就要转换，这个过程包含两部分，首先转换为RGBA，在由RGBA转换为internalFormat。format转换为RGBA：</p>
<table style="text-align: center; width: 50%; background-color: #ccc;"><tr><th>format</th><th>RBGA</th></tr><tr><td>RED</td><td>R001</td></tr><tr>      <td>GREED</td><td>0G01</td>    </tr>    <tr>        <td>BLUE</td><td>00B1</td>    </tr>    <tr>        <td>ALPHA</td><td>000A</td>    </tr>    <tr>        <td>RGB</td><td>RGB1</td>    </tr>    <tr>        <td>RGBA</td><td>RGBA</td>    </tr>    <tr>        <td>LUMINANCE</td><td>LLL1</td>    </tr>    <tr>        <td>LUMINANCE_ALPHA</td><td>LLLA</td>    </tr></table>

<p>然后RGBA转为internalFormat：<br>INTENSITY = R， LUMINANCE = R， R = R， G = G, B = B， A = A。</p>
<p><strong>gluScaleImage</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GLint gluScaleImage(GLenum format,</span><br><span class="line"> GLsizei wIn, GLsizei hIn, GLenum typeIn, const void* dataIn, </span><br><span class="line"> GLsizei wOut, GLsizei hOut, GLenum typeOut, GLvoid* dataOut);</span><br></pre></td></tr></table></figure></p>
<p>纹理图像的高度和宽度（不包括可选的边框宽度）上的纹理单元的数量必须是2的整数次方，如果源图像不满足这个要求，可以使用这个函数来 <strong>更改纹理图像大小</strong>。参数说明：<br>format：指定像素数据的格式类型。GL_STENCIL_INDEX，GL_DEPTH_COMPONENT，GL_RED，GL_GREEN，GL_BLUE，GL_ALPHA，GL_RGB，GL_RGBA，GL_LUMINANCE，GL_LUMINANCE_ALPHA。<br>wIn，hIn，typeIn：源图像的宽高度和数据类型（GL_UNSIGNED_BYTE，GL_BYTE，GL_BITMAP，GL_UNSIGNED_SHORT，GL_SHORT，GL_UNSIGNED_INT，GL_INT，GL_FLOAT）。<br>dataIn：源图像数据的指针。<br>wOut，hOut，typeOut：新图像的宽高度和数据类型。<br>dataOut：指定目的图像指针。</p>
<p><strong>glGenTextures</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glGenTextures(GLsize n, GLuint* textureNames);</span><br></pre></td></tr></table></figure></p>
<p><strong>用它来命名纹理对象</strong>，原则上来说，任何非零无符号整数都可以用来表示纹理对象名称。但为了避免意外命名，应该使用glGenTexture来命名。该函数就是在数组textureNames中返回n个当前未使用的值，表示纹理的名称。textureNames中返回的值不一定是连续的。可以用glIsTexture来判断一个纹理名称是否在使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLboolean glIsTexture(GLuint textureName);</span><br></pre></td></tr></table></figure></p>
<p>如果textureName是一个已绑定的纹理对象名称，而且未删除就返回GL_TRUE。如果textureName为零或者不是一个现有的纹理对象名称，就返回GL_FALSE。</p>
<p><strong>glBindTexture</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glBindTexture(GLenum target, GLuint textureName);</span><br></pre></td></tr></table></figure></p>
<p>glBindTexture可以 <strong>创建和使用纹理对象</strong>。当一个纹理对象初次绑定时，OpenGL就会创建一个新的纹理对象，并把纹理图像和纹理属性设置为默认值。glTexImage*()，glTexSubImage*()，glCopyTexImage*()，glCopyTexSubImage*()，glTextParameter*()和glPrioritizeTexture()函数的 <strong>后续调用将把数据存储在这个纹理对象中</strong>。当一个纹理对象以后再次绑定时， 它的数据就成为当前的纹理状态。</p>
<p><strong>glTexEnv</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void glTexEnv&#123;if&#125;(GLenum target, GLenum pname, TYPE param);</span><br><span class="line">void glTexEnv&#123;if&#125;v(GLenum target, GLenum pname, const TYPE* param);</span><br></pre></td></tr></table></figure></p>
<p>使用纹理图像对物体表面的颜色进行调整，而不是直接贴图。也可以把纹理图像的颜色与物体表面的原先颜色进行组合。该函数提供适当的参数来 <strong>选择纹理函数</strong>，参数说明：<br>target：设置纹理函数使用GL_TEXTURE_FILTER_CONTROL或GL_TEXTURE_ENV。</p>
<ul>
<li>GL_TEXTURE_FILTER_CONTROL：pname必须是GL_TEXTURELOD_BIAS，param必须是浮点值，作为mipmap细节层参数的偏移值使用。</li>
<li>GL_TEXTURE_ENV：并且pname是GL_TEXTURE_ENV_MODE，那么param必须是GL_DECAL，GL_REPLACE，GL_MODULATE，GL_BLEND，GL_ADD或GL_COMBINE之一；如果pname为GL_TEXTURE_ENV_COLOR，那么param就是包含四个浮点数的数组（RGBA），表示用于GL_BLEND操作的颜色。</li>
<li>GL_POINT_SPRITE：（略）<br>该函数将在后面做详细分析。</li>
</ul>
<p>参考：<a href="http://blog.csdn.net/csxiaoshui/article/details/27543615" target="_blank" rel="external">OpenGL API 之 glTexImage2D</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Qt编译出错--可选解决方法]]></title>
      <url>https://weedt.github.io/2015/06/01/A-solution-of-Qt-builds-error/</url>
      <content type="html"><![CDATA[<p>1.错误：</p>
<blockquote>
<p>错误:C1041: 无法打开程序数据库“mypath\vc120.pdb”；如果要将多个 CL.EXE 写入同一个 .PDB 文件，请使用 /FS</p>
</blockquote>
<a id="more"></a>
<p>解决：</p>
<blockquote>
<p><img src="http://img.blog.csdn.net/20150504221903912" alt=""></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Boost库问题：无法识别的外部符号……]]></title>
      <url>https://weedt.github.io/2015/05/04/The-solution-of-%22unkown-extern-symbol%22-when-using-Boost/</url>
      <content type="html"><![CDATA[<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h4><p>今天在用<strong>Qt</strong>可视化<strong>CGAL</strong>生成的图像的编程过程中遇到以下问题：<br>只要include了CGAL的头文件或者Boost库的头文件，编译就会出现“<strong>无法识别的外部符号</strong>”，“<strong>无法识别的外部命令</strong>”等错误。如下（由于我的问题已经解决，以下图片是我找的，并不是我当时出的问题）：</p>
<a id="more"></a>
<blockquote>
<p><img src="http://img.blog.csdn.net/20150504215548443" alt="错误信息"></p>
</blockquote>
<p>在查找资料后，一直无法解决，我当时想有两种可能：1、需要包含相关的boost头文件；2、需要链接相关库文件，特别是boost库文件。包含几个头文件后无效，就放弃第一种方法。着手第二种方法，该链接什么库文件？我的程序只需要两个库文件：</p>
<blockquote>
<p>libboost_thread-vc120-mt-gd-1_57.lib<br>libboost_system-vc120-mt-gd-1_57.lib</p>
</blockquote>
<p>妈蛋，什么问题？原来这两个库文件是32bit的，我在编译的时候疏忽了，没有加上<strong>address-model=64</strong></p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><p>重新编译这两个库文件</p>
<p>参考1. <a href="http://blog.csdn.net/enotswn/article/details/5934938" target="_blank" rel="external">关于各种无法解析的外部符号问题的相应解决方案 </a></p>
<ol>
<li><a href="http://stackoverflow.com/questions/1066071/boost-linker-error-unresolved-external-symbol-class-boostsystemerror-categ/1067072" target="_blank" rel="external">Boost linker error: Unresolved external symbol “class boost::system::error_category const &amp; __cdecl boost::system::get_system_category(void)”</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySql安装过程“Start Service”失败解决方法]]></title>
      <url>https://weedt.github.io/2015/04/19/A-solution-of-the%20error-of-%E2%80%9CStart%20Service%E2%80%9Din-mysql-installation/</url>
      <content type="html"><![CDATA[<h4 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h4><p>mariadb-5.5.25-winx64</p>
<h4 id="问题产生过程及描述"><a href="#问题产生过程及描述" class="headerlink" title="问题产生过程及描述"></a><strong>问题产生过程及描述</strong></h4><p>在安装MySql过程中遇到MySql服务启动失败问题，提示信息如下：</p>
<blockquote>
<p>Error 1920 service failed to start. Verify that you have sufficient privileges to start system services</p>
</blockquote>
<a id="more"></a>
<p>导致MySql无法安装。软件无法自动启动，我就到<strong>控制面板–&gt;管理工具–&gt;服务</strong>下找到MySql服务，手动打开，结果too young too simple，无法打开，提示<strong>1067</strong>错误。 </p>
<p>在网上查找资料，很多都是说<em>重新安装来解决</em>，由于<strong>数据库只能装一次，如果你在你第一次没有装成功的情况下，你必须要卸载干净才能装得上</strong>，我就清除与mysql相关文件及注册表，再重装，依然失败；Reboot，继续失败。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a><strong>解决方法</strong></h4><p>我在安装过程中发现，可以先安装MySql而不安装MySql服务，我就想应该可以后来手动安装MySql服务。<br>于是将与mysql相关文件及注册表清除干净后，再次重装，在安装引导过程中，不勾选“<strong>install MySql service</strong>”，…，可以顺利安装完毕。<br>然后手动安装MySql Service：</p>
<ol>
<li>以<strong>管理员</strong>身份启动命令提示符窗口.</li>
<li>切换到MySql安装目录的bin目录下（&gt;cd …\…\MariaDB\bin）。</li>
<li>执行<strong>mysqld -install</strong>（&gt;mysqld -install），等待安装完毕。</li>
<li>执行<strong>net start mysql</strong>（&gt;net start mysql），等待启动完毕。<br><img src="http://img.blog.csdn.net/20150419115448365" alt=""></li>
<li>安装完成。</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Visual Studio Command Prompt 工具配置方法]]></title>
      <url>https://weedt.github.io/2015/04/18/Visual-Studio-Command-Prompt-configure/</url>
      <content type="html"><![CDATA[<h4 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h4><p>VS2013</p>
<h4 id="如何打开这个工具？"><a href="#如何打开这个工具？" class="headerlink" title="如何打开这个工具？"></a>如何打开这个工具？</h4><ol>
<li>打开VS2013，在“<strong>工具</strong>“菜单下可以找到。</li>
<li>打开”<strong>开始</strong>“，在程序菜单中找到VS2013，打开”<strong>Visual Studio Tools</strong>“，可以找到<strong>Visual Studio Command Prompt</strong></li>
<li>百度一下，有更多方法。</li>
</ol>
<a id="more"></a>
<h4 id="如何增加这个工具"><a href="#如何增加这个工具" class="headerlink" title="如何增加这个工具"></a>如何增加这个工具</h4><p>如果实在找不到这个工具，那就是没有自动配置，我们可以手动增加这个工具：</p>
<ol>
<li>打开VS2013，”<strong>工具</strong>“ –&gt; ”<strong>外部工具</strong>“，如下窗口：<br><img src="http://img.blog.csdn.net/20150418221830238" alt=""></li>
<li>点击”添加“，设置标题，命令和参数：<br>标题：<strong>Visual Studio Command Prompt</strong><br>命令：<strong>C:\Windows\System32\cmd.exe</strong><br>参数：<strong>%comspec% /k “”D:\Development\VS2013\VC\vcvarsall.bat”” x86</strong></li>
<li>点击”确定“，增加成功。</li>
</ol>
<h4 id="64-bit和32-bit"><a href="#64-bit和32-bit" class="headerlink" title="64-bit和32-bit"></a>64-bit和32-bit</h4><p>这个工具也分64位和32位，在不同情况下使用不同工具，应该要切换使用。<br>参考这篇文章<a href="https://msdn.microsoft.com/en-us/library/x4d2c09s.aspx" target="_blank" rel="external">How to: Enable a 64-Bit Visual C++ Toolset on the Command Line</a>，我们可以使用以下方法：</p>
<ul>
<li>打开命令行，切换到VS安装目录的VC目录下（…\…\Visual Studio 2013\VC），执行”<strong>vcvarsall amd64</strong>“，便可切换为64位工具。更多命令参考上面链接。</li>
<li>另外，我们也可以在VS的外部工具管理窗口，对Visual Studio Command Prompt设置参数，来打开64位或者32位工具。如上添加Visual Studio Command Prompt过程中，设置工具参数：<br>”<strong>%comspec% /k “”D:\Development\VS2013\VC\vcvarsall.bat”” x86</strong>“  为32位<br>”<strong>%comspec% /k “”D:\Development\VS2013\VC\vcvarsall.bat”” amd64</strong>“  为64位</li>
</ul>
<p>注意，每次在使用前可以检查到底是64位还是32位，以免出错。检查方法：<br>打开Visual Studio Command Prompt后，执行<strong>cl.exe</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[boost库编译参数小结]]></title>
      <url>https://weedt.github.io/2015/04/18/The-compilling-parameters-of-boost-lib/</url>
      <content type="html"><![CDATA[<h4 id="32位编译："><a href="#32位编译：" class="headerlink" title="32位编译："></a>32位编译：</h4><p>从开始菜单启动Visual Studio 2013的vs2013 命令行，进入boost所在目录，运行bootstrap.bat<br>编译命令（例）：<br><code>bjam.exe stage --toolset=msvc-12.0 --without-math  --stagedir=&quot;vc12_x86&quot; link=static runtime-link=shared threading=multi debug release</code></p>
<a id="more"></a>
<p><strong>toolset</strong>：指定编译器，可选的如borland、gcc、msvc（VC6）、msvc-10.0（VS2010）(vs2008 : msvc-9.0，vs2010 : msvc-10.0, VS2012、VS2013是msvc-12.0)<br><strong>stagedir</strong>:表示编译生成文件的路径。build-dir：编译生成的中间文件的路径。这个本人这里没用到，默认就在根目录（D:\boost\boost_1_57_0）下，目录名为bin.v2（删掉），等编译完成后可将这个目录全部删除（没用了），所以不需要去设置。<br><strong>without/with</strong>：选择不编译/编译哪些库。<br><strong>address-model</strong>：要有address-model=64属性，如果没有这个属性的话，会默认生成32位的平台库，加入这个选项才能生成64位的DLL。<br><strong>threading</strong>：单/多线程编译。一般都写多线程程序，当然要指定multi方式了；如果需要编写单线程程序，那么还需要编译单线程库，可以使用single方式。<br><strong>link</strong>：静态库版link=shared，动态库link=shared<br><strong>runtime-link</strong>：动态/静态链接C/C++运行时库。同样有shared和static两种方式，这样runtime-link和link一共可以产生4种组合方式，各人可以根据自己的需要选择编译。一般link只选static的话，只需要编译2种组合即可，即link=static runtime-link=shared和link=static runtime-link=static。<br><strong>debug/release</strong>：编译debug/release版本。一般都是程序的debug版本对应库的debug版本，所以两个都编译。</p>
<h4 id="64位编译："><a href="#64位编译：" class="headerlink" title="64位编译："></a>64位编译：</h4><p>从开始菜单启动Visual Studio 2013的vs2013 x64兼容工具命令行，然后转到boost根文件夹，运行bootstrap.bat生成x64版的bjam.exe。<br>在编译命令中加入address-model=64属性</p>
<h5 id="windows下boost库的命名特点："><a href="#windows下boost库的命名特点：" class="headerlink" title="windows下boost库的命名特点："></a>windows下boost库的命名特点：</h5><p><code>link=static runtime-link=static 得到 libboostxxxxx.lib
link=shared runtime-link=shared 得到 boostxxxx.lib 和 boostxxxx.dll</code></p>
<p>由以上的文件夹层次结构基本就可以得出结论：<br>１、以“lib”开头的是“link-static”版本的，而直接以“boost”开头的是“link-shared”版本的。<br>２、有“d”的为debug版本，没有的则是release版本。<br>３、有“s”的为“runtime-link-static”版本，没有的则是“runtime-link-shared”版本。<br>４、有“mt”的为“threading-multi”版本，没有的则是“threading-single”版本。</p>
<hr>
<p>本文参考：<a href="http://m.blog.csdn.net/blog/chenjh213/42265605" target="_blank" rel="external">vs2013 boost库编译小结</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Win8.1 x64 + VS2013 下CGAL安装及配置]]></title>
      <url>https://weedt.github.io/2015/04/15/The-installation-and-configuration-of-cgal-under-Win8.1-x64+VS2013/</url>
      <content type="html"><![CDATA[<p>本文基本参考CGAL官网提供的安装方法，但是重点在于在我安装过程中遇到的<strong>问题和解决方法</strong>。<br><a id="more"></a></p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><ul>
<li>Windows8.1 x64</li>
<li>VS2013 x64</li>
<li><a href="http://www.cmake.org/download/" target="_blank" rel="external">CMake3.2.2</a></li>
<li><a href="http://www.cgal.org/download.html" target="_blank" rel="external">CGAL4.6</a></li>
<li><a href="http://www.boost.org/users/download/" target="_blank" rel="external">Boost1.57</a></li>
<li><a href="http://www.qt.io/zh-hans/download-open-source/#section-2" target="_blank" rel="external">Qt4.8.6</a></li>
<li><a href="http://www.libqglviewer.com/download.html" target="_blank" rel="external">libQGLViewer-2.6.1</a></li>
</ul>
<h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="安装CMake"><a href="#安装CMake" class="headerlink" title="安装CMake"></a>安装CMake</h3><p>略</p>
<hr>
<h3 id="安装Boost"><a href="#安装Boost" class="headerlink" title="安装Boost"></a>安装Boost</h3><p>我下载的是boost_1_57源码，所以需要自己编译。执行下面动作：</p>
<ol>
<li>打开命令行窗口（Win + R）。</li>
<li>切换到boost目录（&gt;cd …/…/boost_1_57）。</li>
<li>执行bootstrap.bat（&gt;bootstrap.bat），等待执行完毕，目录会出现<strong>b2.exe</strong>、<strong>bjam.exe</strong>，查资料说他们基本一样，<strong>b2.exe</strong>是<strong>bjam.exe</strong>新版本而已。</li>
<li>开始编译，执行<strong>b2.exe</strong>（&gt;b2.exe）。</li>
<li>编译完毕。</li>
</ol>
<p>编译完毕之后要将boost相关目录加入环境变量<br>BOOST_LIBRARYDIR = …\…\boost_1_57\stage\lib<br>BOOST_INCLUDEDIR(or BOOST_ROOT)=…\…\boost_1_57</p>
<p>而且将<strong>“…\…\boost_1_57\stage\lib”</strong>，加入到环境变量PATH中</p>
<hr>
<p><strong>可能会出现的问题及解决方法</strong><br>在编译CGAL的过程中有可能会出现下面问题<br><img src="http://img.blog.csdn.net/20150418161908130" alt=""><br><strong>解决方法</strong><br>回到boost编译过程中，用以下命令：<br> “&gt;b2 –toolset=msvc-12.0 link=shared runtime-link=shared –with-system –with-thread”<br> 编译完毕之后，就可以在“…\…\boost_1_57”目录下看见：<br><img src="http://img.blog.csdn.net/20150418162316311" alt=""></p>
<hr>
<h3 id="安装Qt"><a href="#安装Qt" class="headerlink" title="安装Qt"></a>安装Qt</h3><p>Qt是用来运行CGAL 3D demo的，可以不装。<br>注意，CGAL是不支持Qt5的，请不要尝试下载安装Qt5来编译。<br>32位Qt4可直接下载安装，但是没有64位的Qt4，需要自己编译。我下载的是<strong>qt-everywhere-opensource-src-4.8.6</strong>，以下是编译过程：</p>
<ol>
<li>打开<strong>Visual Studio  Command Prompt</strong> （建议看看<a href="">注意事项</a>）。</li>
<li>切换到Qt源码目录（&gt;cd …/…/qt-everywhere-opensource-src-4.8.6）。</li>
<li>执行<strong>Configure.exe</strong>（&gt;Configure.exe，你可以加入<a href="http://blog.csdn.net/dztaopao/article/details/9243269" target="_blank" rel="external">一些参数</a>），等待配置结束。</li>
<li>执行<strong>nmake</strong>（&gt;nmake，你可以加入<a href="">一些参数</a>），等待编译结束，过程大概2-3小时。</li>
<li>编译结束后记得执行<strong>nmake clean</strong>（&gt;nmake clean）来清除临时文件。</li>
</ol>
<p>编译结束后将Qt项目目录加入环境变量<br>QTDIR=…\…\qt-everywhere-opensource-src-4.8.2</p>
<p>而且将<strong>“…\…\qt-everywhere-opensource-src-4.8.2\bin”</strong>加入到环境变量PATH中</p>
<hr>
<p><strong>可能会出现的问题及解决方法 </strong><br>在用VS2013编译CGAL时，CGAL_Qt4等生成失败。<br>在我的案例中，是用<strong>Visual Studio Command Prompt</strong>编译Qt时有问题。请注意，VS Command Prompt 有32位版本和64位版本，在我这个案例中，应该要用64位的工具。<br><strong>解决方法</strong><br>如下启用64位：</p>
<ol>
<li>打开命令行窗口。</li>
<li>切换到“…\…\Microsoft Visual Studio 12.0\VC“目录下（&gt;cd …/…/Microsoft Visual Studio 12.0/VC）。</li>
<li>执行<strong>vcvarsall amd64</strong>（&gt;vcvarsall amd64）。</li>
</ol>
<p>或者</p>
<ol>
<li>打开<strong>VS2013</strong> –&gt; <strong>工具</strong> –&gt; <strong>外部工具</strong></li>
<li>如下界面中，选中<strong>Visual Studio Command Prompt</strong>，在参数栏中设置成：<strong>”%comspec% /k “”D:\Development\VS2013\VC\vcvarsall.bat”” amd64“</strong><br><img src="http://img.blog.csdn.net/20150418203400384" alt=""></li>
</ol>
<hr>
<h3 id="安装-amp-编译CGAL"><a href="#安装-amp-编译CGAL" class="headerlink" title="安装&amp;编译CGAL"></a>安装&amp;编译CGAL</h3><p>将CGAL安装到指定目录，选择你需要的版本（32-bit 或者 64-bit），我这里是选择64-bit。注意记得勾选<strong>GMP</strong>和<strong>MPFR</strong>。<br>然后设置环境变量：<br>    CGAL_DIR = …\…\CGAL-4.6</p>
<p>接下来用CMake和VS编译CGAL</p>
<ol>
<li>打开CMake-GUI</li>
<li>在<strong>Where is the source code</strong>后面选择CGAL安装路径，在<strong>Where to build the binaries</strong>后面选择CGAL编译文件路径。</li>
<li>点击<strong>Configure</strong>，选择合适编译工具。我这里选择<strong>Visual Studio 12 2013 Win64</strong>。</li>
<li>点击<strong>Generate</strong>。</li>
<li>打开CGAL编译文件目录，用VS2013打开<strong>CGAL.sln</strong>。</li>
<li>分别用<strong>Debug</strong>和<strong>Release</strong>两种方式编译生成解决方案。</li>
</ol>
<p>成功之后，将<strong>”…\…\CGAL-4.6\bin“</strong>加入到环境变量PATH中。</p>
<hr>
<p><strong>可能会出现的问题及解决方法 </strong><br><strong>Error1</strong>： 在用CMake编译CGAL时，无法找到Qt4：<br><img src="http://img.blog.csdn.net/20150418210824923" alt=""><br>这是提示Qt没有正确安装。<br><strong><em>解决方法</em></strong></p>
<ol>
<li>如果安装Qt4了，就要设置Qt4的相关环境变量。</li>
<li>看看是不是安装的Qt5，CGAL不支持Qt5，需要重装为Qt4。</li>
</ol>
<p><strong>Error2</strong>： 在用CMake编译CGAL时，出现”cannot find GMP”：<br><strong><em>解决方法</em></strong><br>重装一下CGAL。</p>
<hr>
<h3 id="安装及配置libQGLViewer"><a href="#安装及配置libQGLViewer" class="headerlink" title="安装及配置libQGLViewer"></a>安装及配置libQGLViewer</h3><p>libQGLViewer是用来运行CGAL 3D demo的。下面是配置方法：</p>
<ol>
<li>解压到指定目录<strong>”…\…\libQGLViewer-2.6.1“</strong>。</li>
<li>打开命令行窗口，切换到<strong>QGLViewer</strong>目录下（&gt;cd …\…\libQGLViewer-2.6.1\QGLViewer）。</li>
<li>执行<strong>qmake.exe</strong>（&gt;qmake.exe），等待完毕。</li>
<li>打开<strong>Visual Studio Command Prompt</strong>，切换到<strong>QGLViewer</strong>目录下（&gt;cd …\…\libQGLViewer-2.6.1\QGLViewer）。</li>
<li>执行<strong>nmake</strong>（&gt;nmake），等待执行完毕。</li>
</ol>
<p>然后，将<strong>D:\Development\libQGLViewer-2.6.1\QGLViewer\debug</strong>和<strong>D:\Development\libQGLViewer-2.6.1\QGLViewer\release</strong>加入到环境变量PATH中。<br>而且，将libQGLViewer相关目录设置为环境变量：<br>    QGLVIEWERROOT = …\…\libQGLViewer-2.6.1</p>
<p>至此，整个环境就配置好了。如何查看及demos和examples可以参考CGAL<a href="http://www.cgal.org/download/windows.html#CompilinganExample" target="_blank" rel="external">官方提供方法</a><br>有问题可以交流（weed_t@outlook.com）。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Qt 编码问题]]></title>
      <url>https://weedt.github.io/2014/08/20/The-knowledge-of-Qt-endcoding/</url>
      <content type="html"><![CDATA[<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>首先看一个简单的程序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">﻿#include &lt;QCoreApplication&gt;</span><br><span class="line">#include &lt;QTextStream&gt;</span><br><span class="line">#include &lt;QTextCodec&gt;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QCoreApplication a(argc, argv);</span><br><span class="line">    QString str = &quot;我是中文&quot;;</span><br><span class="line">    QTextStream out(stdout);</span><br><span class="line">    out &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>输出结果为：<br><img src="http://ww3.sinaimg.cn/large/93736429gw1f2ohe36n7dj206m039web.jpg" alt=""><br>中文乱码了。<br>我们在之前（<a href="http://weedt.github.io/2014/08/12/show-Chinese-text-in-Qt/">点这里</a>）讨论过解决办法。<br>今天来讨论一下为什么这么解决。</p>
<h4 id="探讨"><a href="#探讨" class="headerlink" title="探讨"></a>探讨</h4><hr>
<p>这是QString对中文字符不支持吗？不是，QString内部使用 <strong>Unicode</strong> 编码，当然是支持中文的。出现输出乱码问题是编码问题。<br>文本文件都是有编码的，比如GBK，UTF-8，以上例子的源文件编码就是GBK。同一个文件用不同的编码，虽然看上去内容一样，但是物理表示方式不同；同理，用A编码存储的内容来用B编码解析，看到的都是乱码（Ps. Windows下压缩包在Linux下解压后中文文件名都是乱码T.T）。开始慢慢明白了，QString内部是Unicode编码，文件中的“我是中文”这几个字符是GBK编码，编码不一致导致乱码问题。但是还有一个问题，保存文件的编码方式千千万，QString对象如何知道文本的编码呢？你不告诉它，它肯定不知道，就会采取默认的方式——Latin-1，把赋值字符串当做 <strong>Latin-1</strong> 编码来转换为Unicode。<br>所以在上面的例子中，把GBK编码的“我是中文”当做Latin-1转换为Unicode，输出当然为乱码。<br><strong>解决方法1</strong>：就是直接转换为Unicode（Windows中local8Bit就是GBK）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString str = QString::fromLocal8Bit(&quot;我是中文&quot;);</span><br></pre></td></tr></table></figure></p>
<p>当然，如果文件为UTF-8编码就采取这种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString str = QString::fromUtf8(&quot;我是中文&quot;);</span><br></pre></td></tr></table></figure></p>
<p>QString提供的转换函数有限，如果没有合适的转换函数，可以使用QTextCodec：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QString QTextCodec::toUnicode ( const char * chars ) const</span><br></pre></td></tr></table></figure></p>
<p><strong>解决办法2</strong>：明确告诉QString你的编码<br>Qt4：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTextCodec::setCodecForCStrings(QTextCodec::codecForName(&quot;GBK&quot;));</span><br></pre></td></tr></table></figure></p>
<p>Qt5：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTextCodec::setCodecForLocale(QTextCodec::codecForName(&quot;GBK&quot;));</span><br></pre></td></tr></table></figure></p>
<p>最后转帖<a href="http://blog.csdn.net/libaineu2004/article/details/19245205" target="_blank" rel="external">这儿</a>的编码知识：<br>Qt常见的两种编码是:UTF-8和GBK</p>
<ul>
<li>UTF-8：Unicode TransformationFormat-8bit，允许含BOM，但通常不含BOM。是用以解决国际上字符的一种多字节编码，它对英文使用8位（即一个字节），中文使用24为（三个字节）来编码。UTF-8包含全世界所有国家需要用到的字符，是国际编码，通用性强。UTF-8编码的文字可以在各国支持UTF8字符集的浏览器上显示。如，如果是UTF8编码，则在外国人的英文IE上也能显示中文，他们无需下载IE的中文语言支持包。</li>
<li>GBK是国家标准GB2312基础上扩容后兼容GB2312的标准。GBK的文字编码是用双字节来表示的，即不论中、英文字符均使用双字节来表示，为了区分中文，将其最高位都设定成1。GBK包含全部中文字符，是国家编码，通用性比UTF8差，不过UTF8占用的数据库比GBD大。GBK是GB2312的扩展，除了兼容GB2312外，它还能显示繁体中文，还有日文的假名。</li>
<li>GBK、GB2312等与UTF8之间都必须通过Unicode编码才能相互转换：<br>GBK、GB2312－－Unicode－－UTF8<br>UTF8－－Unicode－－GBK、GB2312 </li>
<li>在简体中文windows系统下，ANSI编码代表GBK/GB2312编码，ANSI通常使用0x80~0xFF范围的2个字节来表示1个中文字符。0x00~0x7F之间的字符，依旧是1个字节代表1个字符。Unicode(UTF-16)编码则所有字符都用2个字节表示。</li>
</ul>
<p>参考：<a href="http://blog.csdn.net/brave_heart_lxl/article/details/7186631" target="_blank" rel="external">Qt中文乱码问题</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Qt下中文显示问题]]></title>
      <url>https://weedt.github.io/2014/08/12/Show-Chinese-text-in-Qt/</url>
      <content type="html"><![CDATA[<p>Qt 4:<br>main函数中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QTextCodec::setCodecForTr(QTextCodec::codecForName(&quot;GB2312&quot;));  </span><br><span class="line">QTextCodec::setCodecForLocale(QTextCodec::codecForName(&quot;GB2312&quot;));  </span><br><span class="line">QTextCodec::setCodecForCStrings(QTextCodec::codecForName(&quot;GB2312&quot;));</span><br></pre></td></tr></table></figure></p>
<p>需要添加头文件：#include <qtextcodec></qtextcodec></p>
<a id="more"></a>
<p>Qt 5<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QTextCodec::setCodecForLocale(QTextCodec::codecForName(&quot;GB2312&quot;));</span><br></pre></td></tr></table></figure></p>
<p>Qt5中取消了setCodecForCStrings和setCodecForTr</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[QObject::connect:No such slot问题解决办法]]></title>
      <url>https://weedt.github.io/2014/08/02/The-solution-of-QObject-connect-No-such-slot/</url>
      <content type="html"><![CDATA[<p>参考<a href="http://blog.csdn.net/changli_90/article/details/8018376" target="_blank" rel="external">网上</a>，有以下解决方法：</p>
<blockquote>
<p>1、看看你的类声明中有没有Q_OBJECT<br>2、你声明的函数要加声明:<br>     private slots:<br>        void xxxx();<br>3、检查槽函数名拼写是否有误，以及对应的signal和slot的参数是否一致<br>如果还不行的话,清理项目,删掉原有的moc_xxx.cpp,重新执行qmake.<br>还有一点要注意的是:signal和slots的参数要一样 </p>
</blockquote>
<a id="more"></a>
<p>我在实际操作中遇到一下错误：</p>
<blockquote>
<p>加入Q_OBJECT后出现以下错误：<br>错误 1 error LNK2001: 无法解析的外部符号 “public: virtual struct QMetaObject const <em> __thiscall Widget::metaObject(void)const “ (?metaObject@Widget@@UBEPBUQMetaObject@@XZ)<br>错误 2 error LNK2001: 无法解析的外部符号 “public: virtual void </em> <strong>thiscall Widget::qt_metacast(char const *)” (?qt_metacast@Widget@@UAEPAXPBD@Z)<br>错误 3 error LNK2001: 无法解析的外部符号 “public: virtual int </strong>thiscall Widget::qt_metacall(enum QMetaObject::Call,int,void <em> </em>)” (?qt_metacall@Widget@@UAEHW4Call@QMetaObject@@HPAPAX@Z)<br>错误 4 fatal error LNK1120: 3 个无法解析的外部命令  </p>
</blockquote>
<p><strong>解决方法：</strong><br>qmake一下 </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[new内存失败后的正确处理]]></title>
      <url>https://weedt.github.io/2014/06/11/How-to-handle-the-%22new%22-failure/</url>
      <content type="html"><![CDATA[<blockquote>
<p><a href="http://book.51cto.com/art/201202/317767.htm" target="_blank" rel="external">http://book.51cto.com/art/201202/317767.htm</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[malloc/free and new/delete]]></title>
      <url>https://weedt.github.io/2014/04/01/The-Difference-of-malloc-free-and-new-delete/</url>
      <content type="html"><![CDATA[<p>今天在Qt下编写一个解析PCAP文件的小程序时，犯了一个基本错误：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; </span><br><span class="line">    QString openUrl; </span><br><span class="line">    QString saveDir; </span><br><span class="line">    <span class="keyword">int</span> curFilterIndex; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; </span><br><span class="line">        saveDir = <span class="string">"b"</span>; </span><br><span class="line">        openUrl = <span class="string">"a"</span>; </span><br><span class="line">        curFilterIndex = <span class="number">0</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; Dlg_Attr;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p><strong>QString</strong>是Qt框架下的一个字符串类，和std::string基本类似，然而在这个程序中我却习惯性给struct用了malloc来分配空间，结果导致错误。改用new自然就成功了。</p>
<p><strong><code>malloc/free：</code></strong><br>这是两个C/C++的标准库函数，函数原型为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void* malloc(int size);</span><br><span class="line">void free(void* ptr);</span><br></pre></td></tr></table></figure></p>
<p>malloc只是进行分配指定大小内存，返回空间的首地址，并且是void类型的。free也只是回收内存。</p>
<p><strong><code>new/delete：</code></strong><br>这是两个C++关键字，为对象的动态创建和销毁提供支持。</p>
<p><strong>不同</strong><br>两者最大的不同就是：malloc/free只是简单得进行内存分配，而new/delete是关键字，由编译器控制，不仅仅是分配空间，而且会执行构造函数和析构函数对对象进行创建和销毁。<br>另外，malloc分配的空间是无类型的，需要进行强制类型转换来转换成所需的类型；而new需要提供类型来创建对应类型的对象。</p>
<p>前面的QString是类，用malloc当然不行啊，没有对它进行构造，没法用。<br>new/delete的特性是和C++的面向对象思想匹配的，在C++里面还是用new/delete吧。</p>
<p>Ps：struct在C++里面和class基本上没啥差别，除了默认访问权限和默认继承权限不同，struct的都是public，而class的都是private。</p>
]]></content>
    </entry>
    
  
  
</search>
